method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
View(data)
data <- painel[, -c(1:2)]
data$inflacao_mensal <- data$inflacao_mensal+1
# data$inflacao_mensal <- data$inflacao_mensal+1
data <- diff(as.matrix(log(data)))
rownames(data) = seq(length=nrow(data))
data <- painel[, -c(1:2)]
data$inflacao_mensal <- data$inflacao_mensal+1
# +n to inflation series to allow for log-diff
# data$inflacao_mensal <- data$inflacao_mensal+1
data <- diff(as.matrix(log(data)))
rownames(data) = seq(length=nrow(data))
# sample <- createTimeSlices(y = as.matrix(data), initialWindow = 120, horizon = 12, fixedWindow = TRUE)
# data_train <- data[sample$train[[1]],]
# data_test <- data[sample$test[[1]],]
model_recipe <- recipe(x = data, dolar_venda_mensal ~ .) #%>%
#step_normalize(all_numeric_predictors())
model_recipe
summary(model_recipe)
tidy(model_recipe)
# _________________________________________________________________________________
# __________________________________ MODEL _________________________________________
# _________________________________________________________________________________
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 124)
for (i in 1:123) seeds[[i]] <- sample.int(1000, 15)
## For the last model:
seeds[[124]] <- sample.int(1000, 1)
registerDoParallel(cores = 4) # número de núcleos de processamento
# Ajustes da validação cruzada
myTimeControl <- trainControl(
method = "timeslice",
initialWindow = 120,
horizon = 12,
fixedWindow = TRUE,
allowParallel = TRUE,
savePredictions = TRUE,
seeds = seeds, # seeds para garantir reprodutibilidade
returnResamp = "all"
) # Este argumento armazena as samples da validação cruzada
tuneLength.num <- 15 # para o ajuste de parâmetros, peço para o modelo testar quinze alternativas para cada parâmetro.
model_lm <- train(model_recipe,
data = data,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_recipe <- recipe(x = data, dolar_venda_mensal ~ .) #%>%
#step_normalize(all_numeric_predictors())
model_recipe
model_lm <- train(dolar_venda_mensal ~ .,
data = data,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
# TCC forecast: train models
# Bernardo Cainelli Gomes da Silva
# Fev - 2023
# _________________________________________________________________________________
# _____________________________ HELPER FUNCTIONS __________________________________
# _________________________________________________________________________________
source("00_functions.R")
source("01_data.R")
library(caret)
library(doParallel)
library(recipes)
# _________________________________________________________________________________
# _____________________________ PREPROCESS DATA ___________________________________
# _________________________________________________________________________________
data_diff <- painel[, -c(1:2)]
View(data_diff)
data_diff <- painel[, -c(1:2)]
data_diff$inflacao_mensal <- data_diff$inflacao_mensal+1
data_diff <- diff(as.matrix(log(data_diff)))
rownames(data_diff) = seq(length=nrow(data_diff))
data_diff <- painel[, -c(1:2)]
data_diff$inflacao_mensal <- data_diff$inflacao_mensal+1
data_diff <- (as.matrix(log(data_diff)))
data_diff[1,1]
data_diff[2,1]-data_diff[1,1]
data_diff <- painel[, -c(1:2)]
data_diff$inflacao_mensal <- data_diff$inflacao_mensal+1
data_diff <- diff(as.matrix(log(data_diff)))
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 124)
for (i in 1:123) seeds[[i]] <- sample.int(1000, 15)
## For the last model:
seeds[[124]] <- sample.int(1000, 1)
registerDoParallel(cores = 4) # número de núcleos de processamento
# Ajustes da validação cruzada
myTimeControl <- trainControl(
method = "timeslice",
initialWindow = 120,
horizon = 12,
fixedWindow = TRUE,
allowParallel = TRUE,
savePredictions = TRUE,
seeds = seeds, # seeds para garantir reprodutibilidade
returnResamp = "all"
) # Este argumento armazena as samples da validação cruzada
tuneLength.num <- 15 # para o ajuste de parâmetros, peço para o modelo testar quinze alternativas para cada parâmetro.
model_lm <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_svm_r <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "svmRadial",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_svm_l <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "svmLinear",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_svm_p <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "svmPoly",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_rf <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "ctree",
tuneLength = tuneLength.num,
trControl = myTimeControl,
metric = "RMSE"
)
model_MARS <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "earth",
tuneGrid = expand.grid(
.degree = 1, # Preciso entender o que são esses dois parâmetros e porque eles não podem ser estimados com CV
.nprune = 2:25
),
trControl = myTimeControl
)
modelos <- resamples(list(
"Linear Regression" = model_lm,
"Support Vector Machine Kernel Radial" = model_svm_r,
"Support Vector Machine Kernel Linear" = model_svm_l,
#"Support Vector Machine Kernel Polinomial" = model_svm_p,
"Random Forest" = model_rf,
"Splines adaptativos" = model_MARS
))
parallelplot(modelos, metric = "RMSE")
summary(modelos)
trellis.par.set(caretTheme())
dotplot(modelos, metric = "RMSE")
Prev_lm <- predict(model_lm, tail(data, 1))
Prev_lm
Prev_lm <- predict(model_lm, tail(data, 1))
Prev_lm <- predict(model_lm, tail(data_diff, 1))
Prev_lm
model_svm_p <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "svmPoly",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 124)
for (i in 1:123) seeds[[i]] <- sample.int(1000, 10)
## For the last model:
seeds[[124]] <- sample.int(1000, 1)
registerDoParallel(cores = 4) # número de núcleos de processamento
# Ajustes da validação cruzada
myTimeControl <- trainControl(
method = "timeslice",
initialWindow = 120,
horizon = 12,
fixedWindow = TRUE,
allowParallel = TRUE,
savePredictions = TRUE,
seeds = seeds, # seeds para garantir reprodutibilidade
returnResamp = "all"
) # Este argumento armazena as samples da validação cruzada
tuneLength.num <- 15 # para o ajuste de parâmetros, peço para o modelo testar quinze alternativas para cada parâmetro.
model_lm <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_svm_r <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "svmRadial",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 124)
for (i in 1:123) seeds[[i]] <- sample.int(1000, 675#15)
## For the last model:
seeds[[124]] <- sample.int(1000, 1)
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 124)
for (i in 1:123) seeds[[i]] <- sample.int(1000, 675)#15)
## For the last model:
seeds[[124]] <- sample.int(1000, 1)
registerDoParallel(cores = 4) # número de núcleos de processamento
# Ajustes da validação cruzada
myTimeControl <- trainControl(
method = "timeslice",
initialWindow = 120,
horizon = 12,
fixedWindow = TRUE,
allowParallel = TRUE,
savePredictions = TRUE,
seeds = seeds, # seeds para garantir reprodutibilidade
returnResamp = "all"
) # Este argumento armazena as samples da validação cruzada
tuneLength.num <- 15 # para o ajuste de parâmetros, peço para o modelo testar quinze alternativas para cada parâmetro.
675/15
model_svm_p <- train(dolar_venda_mensal ~ .,
data = data_diff,
method = "svmPoly",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
model.frame(dolar_venda_mensal ~ ., data = painel)
str(painel)
model.frame(dolar_venda_mensal ~ inflacao_mensal    , data = painel)
model.frame(dolar_venda_mensal ~ I(inflacao_mensal)^2, data = painel)
model.frame(dolar_venda_mensal ~ I(inflacao_mensal**2), data = painel)
0,84**2
0.84**2
str(painel)
formula <- as.formula("dolar_compra_mensal ~ I(inflacao_mensal**2)")
model.frame(formula, data = painel)
formula <- as.formula("dolar_compra_mensal ~ I(inflacao_mensal**2)")
model.frame(formula, data = painel)
terms(formula)
str(painel)
formula <- as.formula("dolar_compra_mensal ~ I(inflacao_mensal**2) + M1_mensal*pib_mensal")
model.frame(formula, data = painel)
terms(formula)
all.vars(formula)
formula <- as.formula("diff(log(dolar_compra_mensal)) ~ I(diff(log(inflacao_mensal))**2) + diff(log(M1_mensal))*diff(log(pib_mensal))")
model.frame(formula, data = painel)
formula <- as.formula("diff(log(dolar_compra_mensal)) ~ I(diff(log(inflacao_mensal+1))**2) + diff(log(M1_mensal))*diff(log(pib_mensal))")
model.frame(formula, data = painel)
terms(formula)
paste0("oi","lala")
formula <- as.formula(paste0("diff(log(dolar_compra_mensal)) ~ ",
"I(diff(log(inflacao_mensal+1))**2) + diff(log(M1_mensal))*diff(log(pib_mensal))"))
model.frame(formula, data = painel)
terms(formula)
str(painel)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"(.)^2"))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"(.)^2"))
terms(formula_diff)
model.frame(formula_diff, data = painel)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
".*."))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"(diff(log(.)))^2"))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula(paste0("dolar_venda_mensal ~ ",
"(.)^2"))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula(paste0("dolar_venda_mensal ~ ",
".*."))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula("dolar_venda_mensal ~ .*.")
model.frame(formula_diff, data = painel)
terms(formula_diff)
str(painel)
formula_diff <- as.formula(paste0("dolar_venda_mensal ~ ",
"."))
model.frame(formula_diff, data = painel)
str(painel)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"diff(log(M1_mensal)) + ",
"diff(log(inflacao_mensal+1)) + ",
"diff(log(selic_mensal)) + ",
"diff(log(pib_mensal))"))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff_nlin <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"diff(log(M1_mensal))*diff(log(inflacao_mensal+1)) + ",
"diff(log(inflacao_mensal+1)) + ",
"diff(log(selic_mensal)) + ",
"diff(log(pib_mensal))"))
model.frame(formula_diff_nlin, data = painel)
terms(formula_diff_nlin)
formula_diff_nlin <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"diff(log(M1_mensal))*diff(log(inflacao_mensal+1)) + ",
"diff(log(M1_mensal))*diff(log(selic_mensal)) + ",
"diff(log(M1_mensal))*diff(log(pib_mensal)) + "))
model.frame(formula_diff_nlin, data = painel)
terms(formula_diff_nlin)
model_lm <- train(dolar_venda_mensal ~ (.)^2,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
lm.mod
model_lm
model_lm$finalModel
model_lm <- train(diff(log(dolar_venda_mensal)) ~ diff(log((.)))^2,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm
model_lm$finalModel
model_lm$results
model_lm$control$index
model_lm <- train(dolar_venda_mensal ~ (.)^2,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm
model_lm$finalModel
View(data_diff)
str(data_diff)
str(painel)
formula_diff_lin <- as.formula(paste0("dolar_venda_mensal ~ ."))
formula_diff_nlin <- as.formula(paste0("dolar_venda_mensal ~ (.)^2 +",
"I(M1_mensal^2) + I(inflacao_mensal^2)",
"I(selic_mensal^2) + I(pib_mensal^2)"))
model_lm <- train(formula_diff_nlin,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm <- train(dolar_venda_mensal ~ (.)^2 + I(M1_mensal^2) + I(inflacao_mensal^2) + I(selic_mensal^2) + I(pib_mensal^2),
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm
model_lm$finalModel
formula_diff_nlin <- as.formula(paste0("dolar_venda_mensal ~ (.)^2 +",
"I(M1_mensal^2) + I(inflacao_mensal^2) +",
"I(selic_mensal^2) + I(pib_mensal^2)"))
model_lm <- train(formula_diff_nlin,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm
model_lm$finalModel
model.frame(formula_diff_nlin, data = painel)
terms(formula_diff_nlin)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
a <- summary(modelos)
View(a)
summary(modelos)
a
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
a
a <- summary(modelos)
# First difference
data_diff <- painel[, -c(1:2)]
data_diff$inflacao_mensal <- data_diff$inflacao_mensal+1
data_diff <- diff(as.matrix(log(data_diff)))
rownames(data_diff) = seq(length=nrow(data_diff))
formula_diff_lin <- as.formula(paste0("dolar_venda_mensal ~ ."))
formula_diff_nlin <- as.formula(paste0("dolar_venda_mensal ~ (.)^2 +",
"I(M1_mensal^2) + I(inflacao_mensal^2) +",
"I(selic_mensal^2) + I(pib_mensal^2)"))
#model.frame(formula_diff_nlin, data = painel)
#terms(formula_diff_nlin)
# Error Correction
# _________________________________________________________________________________
# __________________________________ MODEL _________________________________________
# _________________________________________________________________________________
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 124)
for (i in 1:123) seeds[[i]] <- sample.int(1000, 15)
## For the last model:
seeds[[124]] <- sample.int(1000, 1)
registerDoParallel(cores = 4) # número de núcleos de processamento
# Ajustes da validação cruzada
myTimeControl <- trainControl(
method = "timeslice",
initialWindow = 120,
horizon = 12,
fixedWindow = TRUE,
allowParallel = TRUE,
savePredictions = TRUE,
seeds = seeds, # seeds para garantir reprodutibilidade
returnResamp = "all"
) # Este argumento armazena as samples da validação cruzada
tuneLength.num <- 15 # para o ajuste de parâmetros, peço para o modelo testar quinze alternativas para cada parâmetro.
model_lm <- train(formula_diff_nlin,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
#model_lm
#model_lm$finalModel
#model_lm$results
#model_lm$control$index
model_svm_r <- train(formula_diff_nlin,
data = data_diff,
method = "svmRadial",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_svm_l <- train(formula_diff_nlin,
data = data_diff,
method = "svmLinear",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
#model_svm_p <- train(dolar_venda_mensal ~ .,
#                     data = data_diff,
#                     method = "svmPoly",
#                     trControl = myTimeControl,
#                     tuneLength = tuneLength.num,
#                     metric = "RMSE"
#)
# svm.mod
# svm.mod$finalModel
# svm.mod$results
# svm.mod$control$index
model_rf <- train(formula_diff_nlin,
data = data_diff,
method = "ctree",
tuneLength = tuneLength.num,
trControl = myTimeControl,
metric = "RMSE"
)
model_MARS <- train(formula_diff_nlin,
data = data_diff,
method = "earth",
tuneGrid = expand.grid(
.degree = 1, # Preciso entender o que são esses dois parâmetros e porque eles não podem ser estimados com CV
.nprune = 2:25
),
trControl = myTimeControl
)
modelos <- resamples(list(
"Linear Regression" = model_lm,
"Support Vector Machine Kernel Radial" = model_svm_r,
"Support Vector Machine Kernel Linear" = model_svm_l,
#"Support Vector Machine Kernel Polinomial" = model_svm_p,
"Random Forest" = model_rf,
"Splines adaptativos" = model_MARS
))
parallelplot(modelos, metric = "RMSE")
summary(modelos)
trellis.par.set(caretTheme())
dotplot(modelos, metric = "RMSE")
Prev_lm <- predict(model_lm, tail(data_diff, 1))
Prev_lm
a
