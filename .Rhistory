metric = "RMSE"
)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
model.frame(dolar_venda_mensal ~ ., data = painel)
str(painel)
model.frame(dolar_venda_mensal ~ inflacao_mensal    , data = painel)
model.frame(dolar_venda_mensal ~ I(inflacao_mensal)^2, data = painel)
model.frame(dolar_venda_mensal ~ I(inflacao_mensal**2), data = painel)
0,84**2
0.84**2
str(painel)
formula <- as.formula("dolar_compra_mensal ~ I(inflacao_mensal**2)")
model.frame(formula, data = painel)
formula <- as.formula("dolar_compra_mensal ~ I(inflacao_mensal**2)")
model.frame(formula, data = painel)
terms(formula)
str(painel)
formula <- as.formula("dolar_compra_mensal ~ I(inflacao_mensal**2) + M1_mensal*pib_mensal")
model.frame(formula, data = painel)
terms(formula)
all.vars(formula)
formula <- as.formula("diff(log(dolar_compra_mensal)) ~ I(diff(log(inflacao_mensal))**2) + diff(log(M1_mensal))*diff(log(pib_mensal))")
model.frame(formula, data = painel)
formula <- as.formula("diff(log(dolar_compra_mensal)) ~ I(diff(log(inflacao_mensal+1))**2) + diff(log(M1_mensal))*diff(log(pib_mensal))")
model.frame(formula, data = painel)
terms(formula)
paste0("oi","lala")
formula <- as.formula(paste0("diff(log(dolar_compra_mensal)) ~ ",
"I(diff(log(inflacao_mensal+1))**2) + diff(log(M1_mensal))*diff(log(pib_mensal))"))
model.frame(formula, data = painel)
terms(formula)
str(painel)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"(.)^2"))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"(.)^2"))
terms(formula_diff)
model.frame(formula_diff, data = painel)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
".*."))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"(diff(log(.)))^2"))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula(paste0("dolar_venda_mensal ~ ",
"(.)^2"))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula(paste0("dolar_venda_mensal ~ ",
".*."))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff <- as.formula("dolar_venda_mensal ~ .*.")
model.frame(formula_diff, data = painel)
terms(formula_diff)
str(painel)
formula_diff <- as.formula(paste0("dolar_venda_mensal ~ ",
"."))
model.frame(formula_diff, data = painel)
str(painel)
formula_diff <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"diff(log(M1_mensal)) + ",
"diff(log(inflacao_mensal+1)) + ",
"diff(log(selic_mensal)) + ",
"diff(log(pib_mensal))"))
model.frame(formula_diff, data = painel)
terms(formula_diff)
formula_diff_nlin <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"diff(log(M1_mensal))*diff(log(inflacao_mensal+1)) + ",
"diff(log(inflacao_mensal+1)) + ",
"diff(log(selic_mensal)) + ",
"diff(log(pib_mensal))"))
model.frame(formula_diff_nlin, data = painel)
terms(formula_diff_nlin)
formula_diff_nlin <- as.formula(paste0("diff(log(dolar_venda_mensal)) ~ ",
"diff(log(M1_mensal))*diff(log(inflacao_mensal+1)) + ",
"diff(log(M1_mensal))*diff(log(selic_mensal)) + ",
"diff(log(M1_mensal))*diff(log(pib_mensal)) + "))
model.frame(formula_diff_nlin, data = painel)
terms(formula_diff_nlin)
model_lm <- train(dolar_venda_mensal ~ (.)^2,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
lm.mod
model_lm
model_lm$finalModel
model_lm <- train(diff(log(dolar_venda_mensal)) ~ diff(log((.)))^2,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm
model_lm$finalModel
model_lm$results
model_lm$control$index
model_lm <- train(dolar_venda_mensal ~ (.)^2,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm
model_lm$finalModel
View(data_diff)
str(data_diff)
str(painel)
formula_diff_lin <- as.formula(paste0("dolar_venda_mensal ~ ."))
formula_diff_nlin <- as.formula(paste0("dolar_venda_mensal ~ (.)^2 +",
"I(M1_mensal^2) + I(inflacao_mensal^2)",
"I(selic_mensal^2) + I(pib_mensal^2)"))
model_lm <- train(formula_diff_nlin,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm <- train(dolar_venda_mensal ~ (.)^2 + I(M1_mensal^2) + I(inflacao_mensal^2) + I(selic_mensal^2) + I(pib_mensal^2),
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm
model_lm$finalModel
formula_diff_nlin <- as.formula(paste0("dolar_venda_mensal ~ (.)^2 +",
"I(M1_mensal^2) + I(inflacao_mensal^2) +",
"I(selic_mensal^2) + I(pib_mensal^2)"))
model_lm <- train(formula_diff_nlin,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_lm
model_lm$finalModel
model.frame(formula_diff_nlin, data = painel)
terms(formula_diff_nlin)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
a <- summary(modelos)
View(a)
summary(modelos)
a
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
a
a <- summary(modelos)
# First difference
data_diff <- painel[, -c(1:2)]
data_diff$inflacao_mensal <- data_diff$inflacao_mensal+1
data_diff <- diff(as.matrix(log(data_diff)))
rownames(data_diff) = seq(length=nrow(data_diff))
formula_diff_lin <- as.formula(paste0("dolar_venda_mensal ~ ."))
formula_diff_nlin <- as.formula(paste0("dolar_venda_mensal ~ (.)^2 +",
"I(M1_mensal^2) + I(inflacao_mensal^2) +",
"I(selic_mensal^2) + I(pib_mensal^2)"))
#model.frame(formula_diff_nlin, data = painel)
#terms(formula_diff_nlin)
# Error Correction
# _________________________________________________________________________________
# __________________________________ MODEL _________________________________________
# _________________________________________________________________________________
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 124)
for (i in 1:123) seeds[[i]] <- sample.int(1000, 15)
## For the last model:
seeds[[124]] <- sample.int(1000, 1)
registerDoParallel(cores = 4) # número de núcleos de processamento
# Ajustes da validação cruzada
myTimeControl <- trainControl(
method = "timeslice",
initialWindow = 120,
horizon = 12,
fixedWindow = TRUE,
allowParallel = TRUE,
savePredictions = TRUE,
seeds = seeds, # seeds para garantir reprodutibilidade
returnResamp = "all"
) # Este argumento armazena as samples da validação cruzada
tuneLength.num <- 15 # para o ajuste de parâmetros, peço para o modelo testar quinze alternativas para cada parâmetro.
model_lm <- train(formula_diff_nlin,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
#model_lm
#model_lm$finalModel
#model_lm$results
#model_lm$control$index
model_svm_r <- train(formula_diff_nlin,
data = data_diff,
method = "svmRadial",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_svm_l <- train(formula_diff_nlin,
data = data_diff,
method = "svmLinear",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
#model_svm_p <- train(dolar_venda_mensal ~ .,
#                     data = data_diff,
#                     method = "svmPoly",
#                     trControl = myTimeControl,
#                     tuneLength = tuneLength.num,
#                     metric = "RMSE"
#)
# svm.mod
# svm.mod$finalModel
# svm.mod$results
# svm.mod$control$index
model_rf <- train(formula_diff_nlin,
data = data_diff,
method = "ctree",
tuneLength = tuneLength.num,
trControl = myTimeControl,
metric = "RMSE"
)
model_MARS <- train(formula_diff_nlin,
data = data_diff,
method = "earth",
tuneGrid = expand.grid(
.degree = 1, # Preciso entender o que são esses dois parâmetros e porque eles não podem ser estimados com CV
.nprune = 2:25
),
trControl = myTimeControl
)
modelos <- resamples(list(
"Linear Regression" = model_lm,
"Support Vector Machine Kernel Radial" = model_svm_r,
"Support Vector Machine Kernel Linear" = model_svm_l,
#"Support Vector Machine Kernel Polinomial" = model_svm_p,
"Random Forest" = model_rf,
"Splines adaptativos" = model_MARS
))
parallelplot(modelos, metric = "RMSE")
summary(modelos)
trellis.par.set(caretTheme())
dotplot(modelos, metric = "RMSE")
Prev_lm <- predict(model_lm, tail(data_diff, 1))
Prev_lm
a
source("~/.active-rstudio-document", echo=TRUE)
z <- rep(0, 10000)
for (i in 2:10000) z[i] <- z[i-1] + rnorm(1)
z
p <- q <- r <- rep(0, 10000)
p <- 0.3*z + rnorm(10000)
q <- 0.6*z + rnorm(10000)
r <- 0.2*z + rnorm(10000)
?ca.jo
jotest=ca.jo(data.frame(p,q,r), type="trace", K=2, ecdet="none", spec="longrun")
summary(jotest)
data.frame(p,q,r)
jotest=ca.jo(data.frame(p,q,r)[1:5000,], type="trace", K=2, ecdet="none", spec="longrun")
summary(jotest)
jotest=ca.jo(data.frame(p,q,r), type="trace", K=2, ecdet="none", spec="longrun")
summary(jotest)
jotest=ca.jo(data.frame(p,q,r), type="trace", K=120, ecdet="none", spec="longrun")
summary(jotest)
jotest
View(jotest)
jotest$x
library(caret)
library(doParallel)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
model_lasso$pred
model_lasso$modelType
model_lasso$modelInfo
model_lasso$finalModel
?predictors
predictors(model_lasso)
install.packages("sidrar")
source("00_functions.R")
info_sidra(1737)
#M1_defasado_diario <- get_sgs("http://api.bcb.gov.br/dados/serie/bcdata.sgs.1821/dados?formato=json", "base_monetaria_m1")
#inflacao_mensal <- get_sgs("http://api.bcb.gov.br/dados/serie/bcdata.sgs.433/dados?formato=json", "inflacao_mensal")#, "ipca")
inflacao_mensal <- get_sidra(x = 1737, variable = 2266)
View(inflacao_mensal)
#M1_defasado_diario <- get_sgs("http://api.bcb.gov.br/dados/serie/bcdata.sgs.1821/dados?formato=json", "base_monetaria_m1")
#inflacao_mensal <- get_sgs("http://api.bcb.gov.br/dados/serie/bcdata.sgs.433/dados?formato=json", "inflacao_mensal")#, "ipca")
inflacao_mensal <- get_sidra(x = 1737, variable = 2266, period = "all", geo = "Brazil")
View(inflacao_mensal)
pib_mensal <- get_sgs("http://api.bcb.gov.br/dados/serie/bcdata.sgs.4380/dados?formato=json", "pib_mensal")
View(pib_mensal)
str(inflacao_mensal)
a <- inflacao_mensal %>% mutate(data = ym(`Mês (Código)`))
View(a)
View(pib_mensal)
a <- inflacao_mensal %>% mutate(data = ym(`Mês (Código)`)) %>% select(data, Valor)
View(a)
colnames(a) <- c("data","inflacao_mensal")
View(a)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/01_data.R", echo=TRUE)
View(painel)
painel <- reduce(list(dolar_compra_mensal, dolar_venda_mensal, M1_mensal,inflacao_mensal, selic_mensal, pib_mensal),full_join, by = "data")
#painel <- painel[rowSums(is.na(painel)) == 0,]
rownames(painel) = seq(length=nrow(painel))
write_csv2(painel, "Painel de dados.csv")
View(painel)
painel <- reduce(list(dolar_compra_mensal, dolar_venda_mensal, M1_mensal,inflacao_mensal, selic_mensal, pib_mensal),full_join, by = "data")
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/01_data.R", echo=TRUE)
View(painel)
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
trellis.par.set(caretTheme())
dotplot(modelos, metric = "RMSE")
View(data_diff)
data_diff %>% last(1)
data_diff %>% tail(1)
View(data_diff)
# First difference
data_diff <- painel[, -c(1:2)]
#data_diff$inflacao_mensal <- data_diff$inflacao_mensal+1
data_diff <- diff(as.matrix(log(data_diff)))
source("~/Bernardo Cainelli Gomes da Silva/Estudo/UFRGS - Ciências Econômicas/09_TCC/forecasts-thesis/02_models.R", echo=TRUE)
trellis.par.set(caretTheme())
dotplot(modelos, metric = "RMSE")
trellis.par.set(caretTheme())
dotplot(modelos, metric = "RMSE")
# First difference
data_diff <- painel[, -c(1:2)]
View(data_diff)
# _________________________________________________________________________________
# __________________________________ MODEL _________________________________________
# _________________________________________________________________________________
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 124)
for (i in 1:123) seeds[[i]] <- sample.int(1000, 15)
## For the last model:
seeds[[124]] <- sample.int(1000, 1)
registerDoParallel(cores = 4) # número de núcleos de processamento
# Ajustes da validação cruzada
myTimeControl <- trainControl(
method = "timeslice",
initialWindow = 120,
horizon = 12,
fixedWindow = TRUE,
allowParallel = TRUE,
savePredictions = TRUE,
seeds = seeds, # seeds para garantir reprodutibilidade
returnResamp = "all"
) # Este argumento armazena as samples da validação cruzada
tuneLength.num <- 15 # para o ajuste de parâmetros, peço para o modelo testar quinze alternativas para cada parâmetro.
model_lm <- train(formula_diff_nlin,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
formula_diff_lin <- as.formula(paste0("dolar_venda_mensal ~ ."))
formula_diff_nlin <- as.formula(paste0("dolar_venda_mensal ~ (.)^2 +",
"I(M1_mensal^2) + I(inflacao_mensal^2) +",
"I(selic_mensal^2) + I(pib_mensal^2)"))
#model.frame(formula_diff_nlin, data = painel)
#terms(formula_diff_nlin)
# Error Correction
# _________________________________________________________________________________
# __________________________________ MODEL _________________________________________
# _________________________________________________________________________________
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 124)
for (i in 1:123) seeds[[i]] <- sample.int(1000, 15)
## For the last model:
seeds[[124]] <- sample.int(1000, 1)
registerDoParallel(cores = 4) # número de núcleos de processamento
# Ajustes da validação cruzada
myTimeControl <- trainControl(
method = "timeslice",
initialWindow = 120,
horizon = 12,
fixedWindow = TRUE,
allowParallel = TRUE,
savePredictions = TRUE,
seeds = seeds, # seeds para garantir reprodutibilidade
returnResamp = "all"
) # Este argumento armazena as samples da validação cruzada
tuneLength.num <- 15 # para o ajuste de parâmetros, peço para o modelo testar quinze alternativas para cada parâmetro.
model_lm <- train(formula_diff_nlin,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
#### creating sampling seeds ####
# Preciso utilizar o argumento seeds de trainControl para garantir reprodutibilidade utilizando computação paralela.
set.seed(123)
seeds <- vector(mode = "list", length = 125)
for (i in 1:124) seeds[[i]] <- sample.int(1000, 15)
## For the last model:
seeds[[125]] <- sample.int(1000, 1)
registerDoParallel(cores = 4) # número de núcleos de processamento
# Ajustes da validação cruzada
myTimeControl <- trainControl(
method = "timeslice",
initialWindow = 120,
horizon = 12,
fixedWindow = TRUE,
allowParallel = TRUE,
savePredictions = TRUE,
seeds = seeds, # seeds para garantir reprodutibilidade
returnResamp = "all"
) # Este argumento armazena as samples da validação cruzada
tuneLength.num <- 15 # para o ajuste de parâmetros, peço para o modelo testar quinze alternativas para cada parâmetro.
model_lm <- train(formula_diff_nlin,
data = data_diff,
method = "lm",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
#model_lm
#model_lm$finalModel
#model_lm$results
#model_lm$control$index
model_svm_r <- train(formula_diff_nlin,
data = data_diff,
method = "svmRadial",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
model_svm_l <- train(formula_diff_nlin,
data = data_diff,
method = "svmLinear",
trControl = myTimeControl,
tuneLength = tuneLength.num,
metric = "RMSE"
)
#model_svm_p <- train(dolar_venda_mensal ~ .,
#                     data = data_diff,
#                     method = "svmPoly",
#                     trControl = myTimeControl,
#                     tuneLength = tuneLength.num,
#                     metric = "RMSE"
#)
# svm.mod
# svm.mod$finalModel
# svm.mod$results
# svm.mod$control$index
model_rf <- train(formula_diff_nlin,
data = data_diff,
method = "ctree",
tuneLength = tuneLength.num,
trControl = myTimeControl,
metric = "RMSE"
)
model_MARS <- train(formula_diff_nlin,
data = data_diff,
method = "earth",
tuneGrid = expand.grid(
.degree = 1, # Preciso entender o que são esses dois parâmetros e porque eles não podem ser estimados com CV
.nprune = 2:25
),
trControl = myTimeControl
)
model_lasso <- train(formula_diff_nlin,
data = data_diff,
method = "lasso",
tuneLength = tuneLength.num,
trControl = myTimeControl,
metric = "RMSE"
)
#predictors(model_lasso)
model_ridge <- train(formula_diff_nlin,
data = data_diff,
method = "ridge",
tuneLength = tuneLength.num,
trControl = myTimeControl,
metric = "RMSE"
)
modelos <- resamples(list(
"Linear Regression" = model_lm,
"Support Vector Machine Kernel Radial" = model_svm_r,
"Support Vector Machine Kernel Linear" = model_svm_l,
#"Support Vector Machine Kernel Polinomial" = model_svm_p,
"Random Forest" = model_rf,
"Adaptative Splines" = model_MARS,
"Lasso" = model_lasso,
"Ridge Regression" = model_ridge
))
parallelplot(modelos, metric = "RMSE")
summary(modelos)
trellis.par.set(caretTheme())
dotplot(modelos, metric = "RMSE")
#Prev_lm <- predict(model_lm, tail(data_diff, 1))
#Prev_lm
